package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

// Dirsize processes a user provided, space-separated list of directories with optional flags and returns a list of their filesizes.

func main() {
	if humanReadable, recursive, paths, err := processInput(os.Args); err != nil {
		fmt.Println("Error:", err)
		os.Exit(1)
	} else if sizeList, err := processPaths(humanReadable, recursive, paths); err != nil {
		fmt.Println("Error:", err)
		os.Exit(1)
	} else {
		if recursive {
			fmt.Println("(Recursive enabled)")
		}
		for path, size := range sizeList {
			fmt.Printf("%s: %s\n", path, size)
		}
	}
}

func processInput(input []string) (humanReadable, recursive bool, paths []string, err error) {
	// Ensure at least one argument has been provided
	if len(input) < 2 || input[1] == "--help" {
		fmt.Println("\n--- Dirsize Help ---\n")
		fmt.Println("Dirsize accepts a list of paths to directories and returns their size.")
		fmt.Println("Example usage: dirsize --flag1 --flag2 path1 path2 pathN ...")
		fmt.Println("\nOptional Flags:\n")
		fmt.Println("'--recursive' flag will obtain the total for all directories within the provided parent directory.")
		fmt.Println("'--human' flag will return human-readable results instead of a byte count.")
		return false, false, []string{}, fmt.Errorf("incomplete command")
	}

	for _, arg := range input[1:] {
		if strings.Contains(arg, "--") {
			chunks := strings.Split(arg, "--")
			if chunks[1] == "human" {
				humanReadable = true
			} else if chunks[1] == "recursive" {
				recursive = true
			}
		} else {
			paths = append(paths, arg)
		}
	}
	return
}

func processPaths(humanReadable, recursive bool, paths []string) (sizeList map[string]string, err error) {
	sizeList = make(map[string]string, len(paths))
	for _, path := range paths {
		if absPath, err := filepath.Abs(path); err != nil {
			return map[string]string{}, err
		} else if size, err := getDirSize(recursive, absPath); err != nil {
			return map[string]string{}, err
		} else if humanReadable {
			sizeList[absPath] = formatSize(size)
		} else {
			sizeList[absPath] = strconv.FormatInt(size, 10)
		}
	}

	return sizeList, nil
}

// formatSize helper was generated by AI to save a little time since it's a straightforward math problem.
func formatSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}
	div, exp := int64(unit), 0
	suffixes := []string{"KB", "MB", "GB"} // Note -- units can go higher, but I'm assuming GBs are a reasonable max for this.
	for n := size / unit; n >= unit && exp < len(suffixes)-1; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.2f %s", float64(size)/float64(div), suffixes[exp])
}

// getDirSize does the heavy lifting for each path.
// If recursive is false, then it'll only process the top-level directory.  It's false by default unless the user toggles it on via input flag.
func getDirSize(recursive bool, path string) (int64, error) {
	info, err := os.Stat(path)
	if err != nil {
		return 0, fmt.Errorf("failed to stat: %v", err)
	}

	// Ensure the path is a directory
	if !info.IsDir() {
		return 0, fmt.Errorf("must provide a valid directory path")
	}

	var totalSize int64

	// Walk the directory and process entries
	err = filepath.WalkDir(path, func(entryPath string, d os.DirEntry, err error) error {
		return processEntry(entryPath, d, path, recursive, &totalSize)
	})

	if err != nil {
		return 0, fmt.Errorf("error walking directory: %v", err)
	}

	return totalSize, nil
}

// processEntry processes each directory entry and updates totalSize accordingly
func processEntry(entryPath string, d os.DirEntry, rootPath string, recursive bool, totalSize *int64) error {
	if err := validateEntry(entryPath, d, rootPath, recursive); err != nil {
		return err
	} else if info, err := d.Info(); err != nil {
		return err
	} else if !info.IsDir() {
		*totalSize += info.Size()
	}

	return nil
}

// validateEntry checks if an entry should be processed or skipped
func validateEntry(entryPath string, d os.DirEntry, rootPath string, recursive bool) error {
	if entryPath == rootPath {
		return nil // Skip processing the root directory itself
	} else if d.IsDir() && !recursive {
		return filepath.SkipDir // Skip subdirectories if not recursive
	}
	return nil // Entry is valid
}
